<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"> 
       
<HTML> 
<HEAD> 
  <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=UTF-8"> 
  <META NAME="GENERATOR" CONTENT="OpenOffice.org 1.9.118  (Win32)">   
  <TITLE>   Ch 6: Indexing</TITLE> 
  <STYLE TYPE="text/css"> 
    TT  {font-size: 12pt; COLOR: BLUE} 
    PRE {font-size: 12pt; COLOR: BLUE} 
                                    
    table.jtable {                  
         border-width: thin;        
         border-spacing: 2px;       
         border-style: solid;       
         border-color: gray;        
         border-collapse: collapse; 
         background-color: white;   
     }                              
     table.jtable td {              
         border-width: 1px;         
         padding: 10px;             
         border-style: solid;       
         border-color: gray;        
         background-color: white;   
     }                              
  </STYLE>
</HEAD>
          
<BODY BGCOLOR=WHITE><!--top jump start--><a href="07.htm">&gt;&gt;</a>&nbsp;
<a href="05.htm">&lt;&lt;</a>&nbsp;
<a href="../user/contents.htm">Usr</a>&nbsp;
<a href="../primer/contents.htm">Pri</a>&nbsp;
<a href="../jforc/contents.htm">JfC</a>&nbsp;
<a href="../learning/contents.htm">LJ</a>&nbsp;
<a href="../phrases/contents.htm">Phr</a>&nbsp;
<a href="../dictionary/contents.htm">Dic</a>&nbsp;
<a href="../dictionary/vocabul.htm">Voc</a>&nbsp;
<a href="../dictionary/xmain.htm">!:</a>&nbsp;
<a href="../index.htm">Help</a>&nbsp;
Learning J<hr><!--top jump end--> 
  <table border="0" cellpadding="5" cellspacing="0"  width="100%"> 
  <tr> <td valign="top" width="17%"> <p> </td> 
   <td valign="top" width="83%"> 
 <A NAME="01"></A>
<H1>Chapter 6: Indexing</H1>
Indexing is the name given to selecting of elements of arrays by position. 
This topic 
includes selecting elements, rearranging selected elements to form new arrays, 
and amending, or updating, selected elements of arrays. 
<A NAME="02"></A>
<H2>6.1  Selecting</H2>
The verb <TT>{</TT> (left-brace) is called "From".  The expression <TT>(x { y)</TT> 
selects elements from <TT>y</TT> according to positions given by <TT>x</TT>.  For example, recall 
from <A HREF="02.htm">Chapter 02</A> that if <TT>L</TT> is a list, then the positions of items 
of <TT>L</TT> are numbered 0 1 and so on.  The expression <TT>(0 { L)</TT> gives the value of the first 
item of <TT>L</TT> and <TT>1 { L</TT> gives the second item.   
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>L =: 'abcdef'</TT></TD>
<TD><TT> 0 { L</TT></TD>
<TD><TT> 1 { L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>a</TT></TD>
<TD><TT>b</TT></TD>
</TABLE>
<p>
The left argument of <TT>{</TT> is called the "index".
<H3>6.1.1  Common Patterns of Selection.</H3>
Several items may be selected together:  
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>L </TT></TD>
<TD><TT>0 2 4 { L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>ace</TT></TD>
</TABLE>
<p>
Items selected from <TT>L</TT> may be replicated and re-ordered:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>L </TT></TD>
<TD><TT>5 4 4 3 { L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>feed</TT></TD>
</TABLE>
<p>
An index value may be negative: a value of <TT>_1</TT> selects the last item, <TT>_2</TT> selects the 
next-to-last item and so on. Positive and negative indices may be mixed.
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>L </TT></TD>
<TD><TT> _1 { L</TT></TD>
<TD><TT> _2 1 { L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>f</TT></TD>
<TD><TT>eb</TT></TD>
</TABLE>
<p>
A single element of a table at, say, row 1 column 2
is selected with an index <TT>(&lt; 1 ; 2)</TT>.
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>T =: 3 3 $ 'abcdefghi'</TT></TD>
<TD><TT> (< 1 ; 2) { T</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def<BR>
ghi</TT></TD>
<TD><TT>f</TT></TD>
</TABLE>
<p>
We can select from a table all elements in specified rows and columns, to produce a 
smaller table (called a subarray).  To select a subarray consisting of, for example rows 
<TT>1</TT> and <TT>2</TT> and columns <TT>0</TT> and <TT>1</TT>, we use an index <TT>(&lt; 1 2; 0 1)</TT>
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>T</TT></TD>
<TD><TT>(< 1 2;0 1) { T</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def<BR>
ghi</TT></TD>
<TD><TT>de<BR>
gh</TT></TD>
</TABLE>
<p>
A complete row or rows may be selected from a table. Recall that a table is a list of items, each 
item being a row. Thus selecting rows from tables is just like selecting items from lists. 
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>T </TT></TD>
<TD><TT>1 { T</TT></TD>
<TD><TT>2 1 { T</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def<BR>
ghi</TT></TD>
<TD><TT>def</TT></TD>
<TD><TT>ghi<BR>
def</TT></TD>
</TABLE>
<p>
To select a complete column or columns,
a straightforward way is
to select all the rows:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>T </TT></TD>
<TD><TT>(< 0 1 2 ; 1 ){ T</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def<BR>
ghi</TT></TD>
<TD><TT>beh</TT></TD>
</TABLE>
<p>
but there are other possibilities: see below.
<A NAME="03"></A>
<H3>6.1.2  Take, Drop, Head, Behead, Tail, Curtail</H3>
Next we look at a group of verbs providing 
some convenient short forms of indexing.
There is a built-in verb <TT>{.</TT> (left brace dot,  
called "Take"). 
The first <TT>n</TT> items of list <TT>L</TT> are selected by 
<TT>(n {. L)</TT> 
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>L</TT></TD>
<TD><TT>2 {. L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>ab</TT></TD>
</TABLE>
<p>
If we take <TT>n</TT> items from <TT>L</TT> with
<TT>(n {. L)</TT>,
and <TT>n</TT> is greater than the length of <TT>L</TT>,
the result is padded to length <TT>n</TT>, with zeros, spaces or 
empty boxes as appropriate. 
<p>
For example, suppose
we require to make a string of exactly 8 characters
from a given string, a description of some kind, which may
be longer or shorter than 8. If longer, we shorten. 
If shorter we pad with spaces.
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>s =: 'pasta'</TT></TD>
<TD><TT># s</TT></TD>
<TD><TT>z =: 8 {. s</TT></TD>
<TD><TT># z</TT></TD>
<TR VALIGN=TOP>
<TD><TT>pasta</TT></TD>
<TD><TT>5</TT></TD>
<TD><TT>pasta&nbsp;&nbsp;&nbsp;</TT></TD>
<TD><TT>8</TT></TD>
</TABLE>
<p>
<A NAME="04"></A>
There is a built-in verb <TT>}.</TT> 
(right-brace dot, called "Drop").
All but the first <TT>n</TT> items of <TT>L</TT> are selected by
<TT>(n }. L)</TT>. 
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>L</TT></TD>
<TD><TT>2 }. L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>cdef</TT></TD>
</TABLE>
<p>
The last <TT>n</TT> items of <TT>L</TT> are selected by 
<TT>(-n) {. L</TT>. 
All but the last <TT>n</TT> are selected by 
<TT>(-n) }. L</TT>
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>L</TT></TD>
<TD><TT>_2 {. L</TT></TD>
<TD><TT>_2 }. L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>ef</TT></TD>
<TD><TT>abcd</TT></TD>
</TABLE>
<p>
<A NAME="05"></A>
<A NAME="06"></A>
There are abbreviations of Take and Drop in
the special case where <TT>n=1</TT>. 
The first item of a list is selected by monadic <TT>{.</TT>
(left-brace dot, called "Head").  All but the first
are selected by <TT>}.</TT> (right-brace dot, called "Behead").
<A NAME="07"></A>
<A NAME="08"></A>
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>L</TT></TD>
<TD><TT>{. L</TT></TD>
<TD><TT>}. L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>a</TT></TD>
<TD><TT>bcdef</TT></TD>
</TABLE>
<p>
The last item of a list is selected by monadic <TT>{:</TT>
(left-brace colon, called "Tail").  All but the last
are selected by <TT>}:</TT> (right-brace colon, called "Curtail".
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>L</TT></TD>
<TD><TT>{: L</TT></TD>
<TD><TT>}: L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>f</TT></TD>
<TD><TT>abcde</TT></TD>
</TABLE>
<p>
<H2>6.2  General Treatment of Selection</H2>
It will help to have some terminology.  In general we will have an n-dimensional array, 
but consider a 3-dimensional array.  A single element is picked out by giving a plane-
number, a row-number and a column-number.  We say that the planes are laid out in 
order along the first axis, and similarly the rows along the second axis, and 
the columns along the third. 
<p>
There is no special notation for indexing; rather the left argument of <TT>{</TT> is 
a data structure which expresses, or encodes, selections and 
rearrangements. This data structure can be built in any way convenient. What follows 
is an explanation of how to build it.
<H3>6.2.1  Independent Selections</H3>
The general expression for indexing is of the form <TT>index { array</TT>. Here <TT>index</TT>
is an array of scalars. Each scalar in <TT>index</TT> gives rise to a separate
independent selection, and the results are assembled together. 
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>L </TT></TD>
<TD><TT> 0 1 { L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>ab</TT></TD>
</TABLE>
<p>
<H3>6.2.2  Shape of Index</H3>
The shape of the results depends on the shape of <TT>index</TT>. 
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>L</TT></TD>
<TD><TT>index =: 2 2 $ 2 0 3 1</TT></TD>
<TD><TT>index { L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>2 0<BR>
3 1</TT></TD>
<TD><TT>ca<BR>
db</TT></TD>
</TABLE>
<p>
The indices must lie within the range <TT>-#L</TT> to <TT>(#L)-1</TT>:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT> L</TT></TD>
<TD><TT>#L</TT></TD>
<TD><TT>_7 { L</TT></TD>
<TD><TT>6 { L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>6</TT></TD>
<TD><TT>error</TT></TD>
<TD><TT>error</TT></TD>
</TABLE>
<p>
<H3>6.2.3  Scalars</H3>
Each scalar in <TT>index</TT> is either a single number or a box (and of course if one is a box, all are.)
If the scalar is a single number it selects an item 
from <TT>array</TT>. 
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>A =: 2 3 $ 'abcdef'</TT></TD>
<TD><TT>1 { A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>def</TT></TD>
</TABLE>
<p>
If the scalar in <TT>index</TT> is a box however then it contains a list of selectors which are applied to successive axes.
To show where a box is used for this purpose, we can use the name <TT>SuAx</TT>, say, for the box function.
<PRE>
<TT>   SuAx =: <</TT>
</PRE>
The following example selects from <TT>A</TT> the element at row 1, column 0. 
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT>(SuAx 1 0) { A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>d</TT></TD>
</TABLE>
<p>
<H3>6.2.4  Selections on One Axis</H3>
In a list of selectors for successive axes, of the form <TT>(SuAx p , r, c)</TT> say,
each of <TT>p</TT>, <TT>r</TT> and <TT>c</TT> is a scalar. 
This scalar is either a number or a box (and if one is boxed, all are).
A number selects one thing on its axis: one plane, row or column as appropriate, as in the last example.
<p>
However, if the selector is a box it contains a list of selections all applicable to the same
axis. To show where a box is used for this purpose we can use the name <TT>Sel</TT>, say, for the box function.
<PRE>
<TT>   Sel =: <</TT>
</PRE>
For example, to select from <TT>A</TT> elements at row 1, columns 0 2:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT>(SuAx (Sel 1), (Sel 0 2)) { A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>df</TT></TD>
</TABLE>
<p>
<H3>6.2.5  Excluding Things</H3>
Instead of selecting things on a particular axis, we can exclude things, by supplying a list of
thing-numbers enclosed in yet another level of boxing.
To show where a box is used for this purpose we can use the name <TT>Excl</TT>, say, for the box function.
<PRE>
<TT>   Excl =: <</TT>
</PRE>
For example, to select from <TT>A</TT> elements at row 0, all columns excluding column 1:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT>(SuAx (Sel 0), (Sel (Excl 1))) { A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>ac</TT></TD>
</TABLE>
<p>
We can select all things on a particular axis by excluding nothing, that is, giving an empty
list <TT>(0$0)</TT> as a list of thing-numbers to exclude.
For example, to select from <TT>A</TT> elements at row 1, all columns:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT>(SuAx (Sel 1),(Sel (Excl 0$0))) { A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>def</TT></TD>
</TABLE>
<p>
<A NAME="09"></A>
<H3>6.2.6  Simplifications</H3>
The expression <TT>(Excl 0$0)</TT> denotes a boxed empty
list. There is a built-in J abbreviation for this,
namely <TT>(a:)</TT> (letter-a colon, called "Ace"), which in this context we can think of as meaning "all".
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT>(SuAx (Sel 1),(Sel a:)) { A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>def</TT></TD>
</TABLE>
<p>
If in any index of the form <TT>(SuAx p,q,..., z)</TT>,
 the last selector <TT>z</TT> is the "all" form, 
<TT>(Sel (Excl 0$0))</TT> or <TT>(Sel a:)</TT>,
 then it can be omitted.
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT>(SuAx (Sel 1),(Sel a:)) {A</TT></TD>
<TD><TT>(SuAx (Sel 1)) {A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>def</TT></TD>
<TD><TT>def</TT></TD>
</TABLE>
<p>
If in any index of the form 
<TT>(SuAx (Sel p),(Sel q),...)</TT>, the "all" form is entirely absent,
then the index can be abbreviated to <TT>(SuAx p;q;...)</TT>. For example, to select elements at
row 1, columns 0 and 2:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT>(SuAx (Sel 1),(Sel 0 2)) {A</TT></TD>
<TD><TT>(SuAx 1;0 2) {A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>df</TT></TD>
<TD><TT>df</TT></TD>
</TABLE>
<p>
Finally, as we have already seen, if selecting only one thing on each axis, a simple unboxed list is sufficient. 
For example to select  the element at row 1, column 2:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>A </TT></TD>
<TD><TT>(SuAx 1;2) { A</TT></TD>
<TD><TT>(SuAx 1 2) { A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>f</TT></TD>
<TD><TT>f</TT></TD>
</TABLE>
<p>
<H3>6.2.7  Shape of the Result</H3>
Suppose that <TT>B</TT> is a 3-dimensional array:
<PRE>
<TT>   B =: 10 + i. 3 3 3</TT>
</PRE>
and we define <TT>p</TT> to select planes along the first axis 
of <TT>B</TT>,
and <TT>r</TT> to select rows along the second axis, and <TT>c</TT> 
to select columns along the third axis:
<PRE>
<TT>   p =: 1 2</TT>
<TT>   r =: 1 2</TT>
<TT>   c =: 0 1</TT>
</PRE>
We see that, selecting with <TT>p;r;c</TT>, the shape of the result
<TT>R</TT> is the concatenation of the shapes of <TT>p</TT>, <TT>r</TT> and <TT>c</TT>
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>B</TT></TD>
<TD><TT>R =: (< p;r;c) { B</TT></TD>
<TD><TT>$ R</TT></TD>
<TD><TT>($p),($r),($c)</TT></TD>
<TR VALIGN=TOP>
<TD><TT>10 11 12<BR>
13 14 15<BR>
16 17 18<BR>
<BR>
19 20 21<BR>
22 23 24<BR>
25 26 27<BR>
<BR>
28 29 30<BR>
31 32 33<BR>
34 35 36</TT></TD>
<TD><TT>22 23<BR>
25 26<BR>
<BR>
31 32<BR>
34 35</TT></TD>
<TD><TT>2 2 2</TT></TD>
<TD><TT>2 2 2</TT></TD>
</TABLE>
<p>
<TT>B</TT> is 3-dimensional, and so is <TT>R</TT>. As we would expect, 
this concatenation-of-shapes holds 
when a selector (<TT>r</TT>, say) is a list of length one:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>r =: 1 $ 1</TT></TD>
<TD><TT>S =: (< p;r;c){B</TT></TD>
<TD><TT>$ S</TT></TD>
<TD><TT>($p),($r),($c)</TT></TD>
<TR VALIGN=TOP>
<TD><TT>1</TT></TD>
<TD><TT>22 23<BR>
<BR>
31 32</TT></TD>
<TD><TT>2 1 2</TT></TD>
<TD><TT>2 1 2</TT></TD>
</TABLE>
<p>
and the concatenation-of-shapes holds 
when selector <TT>r</TT> is a scalar:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>r =: 1</TT></TD>
<TD><TT>T =: (< p;r;c){B</TT></TD>
<TD><TT>$ T</TT></TD>
<TD><TT>($p),($r),($c)</TT></TD>
<TD><TT>$ r</TT></TD>
<TR VALIGN=TOP>
<TD><TT>1</TT></TD>
<TD><TT>22 23<BR>
31 32</TT></TD>
<TD><TT>2 2</TT></TD>
<TD><TT>2 2</TT></TD>
<TD><TT>&nbsp;</TT></TD>
</TABLE>
<p>
In this last example, <TT>r</TT> is a scalar, so the shape of 
<TT>r</TT> is an empty list, and so the axis corresponding to <TT>r</TT>
has disappeared, and so the result <TT>T</TT> is 2-dimensional.
<A NAME="10"></A>
<A NAME="11"></A>
<H2>6.3  Amending (or Updating)  Arrays</H2>
Sometimes we need to compute an array which is the same as an existing array except 
for new values at a comparatively small number of positions. We may speak of 
'updating' or 'amending' an array at selected positions.  The J function for amending 
arrays is <TT>}</TT> (right brace, called "Amend"). 
<H3>6.3.1  Amending with an Index</H3>
To amend an array we need three things:
<UL>
<LI> the original array
<LI> a specification of the position(s) at which the original is to be amended. This can be 
an index exactly like the index we have seen above for selection with <TT>{</TT>.
<LI> new values to replace existing elements at specified positions.
</UL>
Consequently the J expression to perform an amendment 
may have the general form:
<PRE>
<TT>        newvalues index } original</TT>
</PRE>
For example:  to amend list <TT>L</TT> to replace the first item (at index <TT>0</TT>) with '*':
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>L</TT></TD>
<TD><TT>new=:'*'</TT></TD>
<TD><TT>index=:0</TT></TD>
<TD><TT>new index } L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>*</TT></TD>
<TD><TT>0</TT></TD>
<TD><TT>*bcdef</TT></TD>
</TABLE>
<p>
<TT>}</TT> is an adverb, which 
takes <TT>index</TT> as its argument to yield the dyadic amending verb <TT>(index })</TT>. 
<PRE>
<TT>   ReplaceFirst =: 0 }</TT>
<TT>   '*' ReplaceFirst L</TT>
<TT>*bcdef</TT>
</PRE>
<TT>(index })</TT> is a verb like any other, dyadic and yielding a value in the usual way. 
Therefore to change an array by amending needs the whole of the result to be 
reassigned to the old name.  Thus amendment often takes place on the pattern:
<PRE>
<TT>                 A  =:  new index } A </TT>
</PRE>
The J system ensures that this is an efficient computation with no
unnecessary movement of data.
<p>
To amend a table at row 1 column 2, for example:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT> '*' (< 1 2) } A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>abc<BR>
de*</TT></TD>
</TABLE>
<p>
To amend multiple elements, a list of new values can be supplied, and they are taken 
in turn to replace a list of values selected by an index
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT> L</TT></TD>
<TD><TT> '*#' 1 2 } L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>a*#def</TT></TD>
</TABLE>
<p>
<H3>6.3.2  Amending with a Verb</H3>
Suppose that <TT>Y</TT> is a list of numbers, and we wish to amend it so that all numbers exceeding
a given value <TT>X</TT> are replaced by <TT>X</TT>. 
(For the sake of this
example, we here disregard the built-in J verb 
 <TT>(&lt;.)</TT> for this function.)
<p>
The indices at which <TT>Y</TT> is to be amended must 
be computed from <TT>X</TT> and <TT>Y</TT>.  
Here is a function <TT>f</TT> to compute the indices:
<PRE>
<TT>   f =: 4 : '(y > x) # (i. # y)'</TT>
<TT>   </TT>
</PRE>
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>X =: 100</TT></TD>
<TD><TT>Y =: 98 102 101 99</TT></TD>
<TD><TT>Y > X</TT></TD>
<TD><TT>X f Y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>100</TT></TD>
<TD><TT>98 102 101 99</TT></TD>
<TD><TT>0 1 1 0</TT></TD>
<TD><TT>1 2</TT></TD>
</TABLE>
<p>
The amending is done, in the way we have seen above,
 by supplying indices of <TT>(X f Y)</TT>:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>Y</TT></TD>
<TD><TT>X (X f Y) } Y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>98 102 101 99</TT></TD>
<TD><TT>98 100 100 99</TT></TD>
</TABLE>
<p>
The "Amend" adverb <TT>}</TT> allows the expression 
<TT>(X (X f Y) } Y)</TT>
to be abbreviated as <TT>(X f } Y)</TT>. 
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>X (X f Y) } Y</TT></TD>
<TD><TT>X f } Y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>98 100 100 99</TT></TD>
<TD><TT>98 100 100 99</TT></TD>
</TABLE>
<p>
Since <TT>}</TT> is an adverb, it can accept
as argument either the indices <TT>(X f Y)</TT> or the verb <TT>f</TT>.
<PRE>
<TT>   cap =: f }</TT>
<TT>   </TT>
<TT>   10 cap 8 9 10 11</TT>
<TT>8 9 10 10</TT>
</PRE>
Note that if verb <TT>f</TT> is to be supplied as argument
to adverb <TT>}</TT>, then <TT>f</TT> must be a dyad, although
it may ignore <TT>X</TT> or <TT>Y</TT>. 
<A NAME="12"></A>
<H3>6.3.3  Linear Indices</H3>
We have just looked at amending lists with a verb. The purpose of the verb is to find 
the places at which to amend, that is, to compute from the values in a list the indices at 
which to amend. With a table rather than a list, the indices would have to be  2-
dimensional, and the task of the verb in constructing the indices would be 
correspondingly more difficult.  
It would be easier to flatten a table into a linear list,  
amend it as a list, and rebuild the list into a
 table again.  
<p>
For example, suppose we have a table:
<PRE>
<TT>   M =: 2 2 $ 13 52 51 14</TT>
</PRE>
Then, using our index-finding verb <TT>f</TT>, 
the flattening, amending and rebuilding is shown by:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>M</TT></TD>
<TD><TT>LL =: ,M</TT></TD>
<TD><TT>Z =: 50 f } LL</TT></TD>
<TD><TT> ($M) $ Z</TT></TD>
<TR VALIGN=TOP>
<TD><TT>13 52<BR>
51 14</TT></TD>
<TD><TT>13 52 51 14</TT></TD>
<TD><TT>13 50 50 14</TT></TD>
<TD><TT>13 50<BR>
50 14</TT></TD>
</TABLE>
<p>
However, there is a better way.
First note that our index-finding verb <TT>f</TT> takes as argument, not <TT>M</TT>
but <TT>(LL =: , M)</TT>. Thus information about the original shape of <TT>M</TT>
is not available to the index-finder <TT>f</TT>. 
In this example, this does not matter, but in general
we may want the index-finding to depend upon both the shape and the 
values in <TT>M</TT>. It would be better
if <TT>f</TT> took the whole of <TT>M</TT> as argument.
In this case <TT>f</TT> must do its own flattening.
Thus we redefine <TT>f</TT>:
<PRE>
<TT>   f =: 4 : 0</TT>
<TT>y =. , y</TT>
<TT>(y > x) # (i. # y)</TT>
<TT>)</TT>
<TT>   </TT>
</PRE>
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>M</TT></TD>
<TD><TT>50 f M</TT></TD>
<TR VALIGN=TOP>
<TD><TT>13 52<BR>
51 14</TT></TD>
<TD><TT>1 2</TT></TD>
</TABLE>
<p>
Now the index finder <TT>f</TT> takes an array as 
argument,
and delivers indices into the flattened array, so-called "linear indices".
The amending process, with this new <TT>f</TT>, is shown by:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>M</TT></TD>
<TD><TT>($M) $ 50 (50 f M) } (, M)</TT></TD>
<TR VALIGN=TOP>
<TD><TT>13 52<BR>
51 14</TT></TD>
<TD><TT>13 50<BR>
50 14</TT></TD>
</TABLE>
<p>
Finally, provided <TT>f</TT> delivers linear indices, then <TT>(})</TT> allows
the last expression to be abbreviated as:
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>M</TT></TD>
<TD><TT>50 f } M</TT></TD>
<TR VALIGN=TOP>
<TD><TT>13 52<BR>
51 14</TT></TD>
<TD><TT>13 50<BR>
50 14</TT></TD>
</TABLE>
<p>
<A NAME="13"></A>
<H2>6.4  Merging Together the Items of an Array</H2>
We saw above that <TT> } </TT> is an adverb.  It can be applied to an argument 
<TT>m</TT> to generate a verb, <TT>(m })</TT> . 
We saw above the dyadic case of this verb  being used to amend an array.
<p>
Now we look at the monadic case of <TT>(m })</TT>  .
This verb is known as "Amend Items"
Let us begin with an example.
Suppose <TT> T </TT> is a table:
<PRE>
<TT>   T =: 3 4 $ 'ABCDEFGHIJKL'</TT>
<TT>   </TT>
</PRE>
Let <TT>m</TT> be a list of indices.  
Each item of <TT>m</TT> is intended to be an index into the corresponding 
 column of <TT>T</TT> .
<PRE>
<TT>   m =: 1 2 0 2 </TT>
<TT>    </TT>
</PRE>
Applying the verb <TT>m } </TT> to T, we see that the result is produced 
by indexing down each column separately.
<p>
<TABLE class=jtable>
<TR  VALIGN=TOP>
<TD><TT>T</TT></TD>
<TD><TT>m</TT></TD>
<TD><TT>(m }) T</TT></TD>
<TR VALIGN=TOP>
<TD><TT>ABCD<BR>
EFGH<BR>
IJKL</TT></TD>
<TD><TT>1 2 0 2</TT></TD>
<TD><TT>EJCL</TT></TD>
</TABLE>
<p>
Another way of describing the result is to say that the items of T 
are combined according to the vector <TT>m</TT>.
<p>
The argument of the adverb  <TT> } </TT> can be a boolean array 
which selects from the first or second of two 
alternative arrays.
For example:
<PRE>
<TT>   A =: 'pot'  NB. first alternative</TT>
<TT>   B =: 'dig'  NB. second alternative</TT>
<TT>   1 0 1 }  A ,: B</TT>
<TT>dog</TT>
<TT>   </TT>
<TT>   </TT>
</PRE>
This is the end of Chapter 6.
  </tr> </table> 
<HR>  
 <p ALIGN=CENTER> 
 <A HREF="07.htm"> NEXT </A> <BR> 
 <A HREF="contents.htm#toc"> Table of Contents </A> <BR> 
<A HREF="kwic.htm"> Index </A> 
<HR> 
<P ALIGN=CENTER> 
<FONT SIZE=-1>The examples in this chapter 
were executed using J version 802 beta. 
 This chapter last updated 14 Jul 2014<BR> 
Copyright &copy; Roger Stokes 2014. 
 This material may be freely reproduced, 
provided that acknowledgement is made. 
</FONT> 
 <!--bottom jump start--><hr><a href="07.htm">&gt;&gt;</a>&nbsp;
<a href="05.htm">&lt;&lt;</a>&nbsp;
<a href="../user/contents.htm">Usr</a>&nbsp;
<a href="../primer/contents.htm">Pri</a>&nbsp;
<a href="../jforc/contents.htm">JfC</a>&nbsp;
<a href="../learning/contents.htm">LJ</a>&nbsp;
<a href="../phrases/contents.htm">Phr</a>&nbsp;
<a href="../dictionary/contents.htm">Dic</a>&nbsp;
<a href="../dictionary/vocabul.htm">Voc</a>&nbsp;
<a href="../dictionary/xmain.htm">!:</a>&nbsp;
<a href="../index.htm">Help</a>&nbsp;
Learning J<!--bottom jump end--></BODY> 
 </HTML> 
 
