<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"> 
    
<HTML> 
<HEAD> 
  <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=ISO-8859-1"> 
  <META NAME="GENERATOR" CONTENT="OpenOffice.org 1.9.118  (Win32)"> 
  <META NAME="CREATED" CONTENT="20051014;16001218"> 
	<META NAME="CHANGED" CONTENT="20051014;16020434"> 
  <title>   Ch 18: Sets, Classes and Relations</title> 
  <STYLE TYPE="text/css"> 
   <!-- 
    TT  {font-size: 11pt; COLOR: BLUE} 
    PRE {font-size: 11pt; COLOR: BLUE} 
   --> 
  </STYLE>
</HEAD>
          
<BODY BGCOLOR=WHITE><!--top jump start--><a href="19.htm">&gt;&gt;</a>&nbsp;
<a href="17.htm">&lt;&lt;</a>&nbsp;
<a href="../user/contents.htm">Usr</a>&nbsp;
<a href="../primer/contents.htm">Pri</a>&nbsp;
<a href="../jforc/contents.htm">JfC</a>&nbsp;
<a href="../learning/contents.htm">LJ</a>&nbsp;
<a href="../phrases/contents.htm">Phr</a>&nbsp;
<a href="../dictionary/contents.htm">Dic</a>&nbsp;
<a href="../release/contents.htm">Rel</a>&nbsp;
<a href="../dictionary/vocabul.htm">Voc</a>&nbsp;
<a href="../dictionary/xmain.htm">!:</a>&nbsp;
<a href="../index.htm">Help</a>&nbsp;
Learning J<hr><!--top jump end--> 
  <table border="0" cellpadding="5" cellspacing="0"  width="100%"> 
  <tr> <td valign="top" width="17%"> <p> </td> 
   <td valign="top" width="83%"> 
 <H1>Chapter 18: Sets, Classes and Relations</H1>
In this chapter we look at more of the built-in functions of J.  
The connecting theme
is, somewhat loosely, working with set, classes and relations.  
<p>
Suppose that, for some list, for the purpose at hand, 
the order of the items is irrelevant and the presence of duplicate items
 is irrelevant. 
Then we can regard the list as (representing) a finite set. 
In the abstract, the set <TT>3 1 2 1</TT>  is considered to be the same set as
 <TT>1 2 3</TT>. 
<p>
The word "class" we will use in the sense in which, for example,  
each integer in a list belongs either to
the odd class or to the even class.
<p>
By "relation" is meant 
a table of two or more columns,
expressing a relationship between a value in one column
and the corresponding value in another.
A relation with two columns, for example, is a set of pairs.
<A NAME="01"></A>
<H2>18.1  Sets</H2>
<A NAME="02"></A>
<H3>18.1.1  Membership</H3>
There is a  built-in verb <TT>e.</TT> (lowercase e dot, called "Member"). 
The expresssion <TT>x e. y</TT> tests whether
<TT>x</TT> matches any item of <TT>y</TT>, that is, whether x is a member of the 
list <TT>y</TT>.
For example:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>y=: 'abcde'</TT></TD>
<TD><TT>'a' e. y</TT></TD>
<TD><TT>'w' e. y</TT></TD>
<TD><TT>'ef' e. y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcde</TT></TD>
<TD><TT>1</TT></TD>
<TD><TT>0</TT></TD>
<TD><TT>1 0</TT></TD>
</TABLE>
<p>
Evidently the order of items in <TT>y</TT> is irrelevant and so is the presence 
of duplicates in <TT>y</TT>.
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>z=: 'edcbad'</TT></TD>
<TD><TT>'a' e. z</TT></TD>
<TD><TT>'w' e. z</TT></TD>
<TD><TT>'ef' e. z</TT></TD>
<TR VALIGN=TOP>
<TD><TT>edcbad</TT></TD>
<TD><TT>1</TT></TD>
<TD><TT>0</TT></TD>
<TD><TT>1 0</TT></TD>
</TABLE>
<p>
We can test whether a table contains a particular row:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>t =: 4 2 $ 'abcdef'</TT></TD>
<TD><TT>'cd' e. t</TT></TD>
<TR VALIGN=TOP>
<TD><TT>ab<BR>
cd<BR>
ef<BR>
ab</TT></TD>
<TD><TT>1</TT></TD>
</TABLE>
<p>
<A NAME="03"></A>
<H3>18.1.2  Less</H3>
There is a built-in verb <TT>-.</TT> (minus dot, called "Less"). 
The expression <TT>x -. y</TT> produces a list of the items of
<TT>x</TT> except those which are members of <TT>y</TT>.
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>x =: 'consonant'</TT></TD>
<TD><TT>y =: 'aeiou'</TT></TD>
<TD><TT>x -. y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>consonant</TT></TD>
<TD><TT>aeiou</TT></TD>
<TD><TT>cnsnnt</TT></TD>
</TABLE>
<p>
Evidently the order of items in <TT>y</TT> is irrelevant and so is the presence of
 duplicates in <TT>y</TT>.
<A NAME="04"></A>
<H3>18.1.3  Nub</H3>
There is a  built-in verb <TT>~.</TT> (tilde dot, called "Nub"). The expression
 <TT>~. y</TT> produces
a list of the items of <TT>y</TT> without duplicates.  
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>nub =: ~.</TT></TD>
<TD><TT>y =: 'hook'</TT></TD>
<TD><TT>nub y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>~.</TT></TD>
<TD><TT>hook</TT></TD>
<TD><TT>hok</TT></TD>
</TABLE>
<p>
We can apply <TT>nub</TT> to the rows of a table:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>t</TT></TD>
<TD><TT>nub t</TT></TD>
<TR VALIGN=TOP>
<TD><TT>ab<BR>
cd<BR>
ef<BR>
ab</TT></TD>
<TD><TT>ab<BR>
cd<BR>
ef</TT></TD>
</TABLE>
<p>
<H3>18.1.4  Nub Sieve</H3>
The verb "nub sieve" <TT>(~:)</TT> gives a 
boolean vector which is true only at 
the nub.
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT> y </TT></TD>
<TD><TT>b =: ~: y</TT></TD>
<TD><TT>b # y</TT></TD>
<TD><TT>nub y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>hook</TT></TD>
<TD><TT>1 1 0 1</TT></TD>
<TD><TT>hok</TT></TD>
<TD><TT>hok</TT></TD>
</TABLE>
<p>
<H3>18.1.5  Functions for Sets</H3>
The customary functions on sets, such as set-union, 
set-intersection or set-equality, are easily defined 
using the built-in functions available.  For example
two sets are equal
if all members of one are members of the other, 
and vice versa.  
<PRE>
   seteq =: *./ @: (e. , e.~)
</PRE>
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>1 2 3 seteq 3 1 2 1</TT></TD>
<TD><TT>1 2 3 seteq 1 2</TT></TD>
<TR VALIGN=TOP>
<TD><TT>1</TT></TD>
<TD><TT>0</TT></TD>
</TABLE>
<p>
<A NAME="05"></A>
<H2>18.2  The Table Adverb</H2>
Recall that the adverb <TT>/</TT> generates a verb; for example <TT>+/</TT> is a verb 
which sums lists. 
More precisely, it is the monadic case of <TT>+/</TT> which sums lists. 
The dyadic case of <TT>+/</TT> generates a table:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>x =: 0 1 2</TT></TD>
<TD><TT>y =: 3 4 5 6</TT></TD>
<TD><TT>z =: x +/ y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>0 1 2</TT></TD>
<TD><TT>3 4 5 6</TT></TD>
<TD><TT>3 4 5 6<BR>
4 5 6 7<BR>
5 6 7 8</TT></TD>
</TABLE>
<p>
The general scheme is that if we have
<PRE>
             z =:  x f/ y
</PRE>
then <TT>z</TT> is a table such that the value at row <TT>i</TT> column <TT>j</TT>
is given by applying <TT>f</TT> dyadically
to the pair of arguments <TT>i{x</TT>
 and <TT>j{y</TT>. That is,
<TT>z</TT> contains all possible pairings 
of an item of <TT>x</TT> with an item of <TT>y</TT>.
Here is another example:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>x =: 'abc'</TT></TD>
<TD><TT>y =: 'face'</TT></TD>
<TD><TT>x =/ y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc</TT></TD>
<TD><TT>face</TT></TD>
<TD><TT>0 1 0 0<BR>
0 0 0 0<BR>
0 0 1 0</TT></TD>
</TABLE>
<p>
The result shows, in the first row,
the value of <TT>'a' = 'face'</TT>, in the second row
the value of <TT>'b' ='face'</TT>
and so on.
<H2>18.3  Classes</H2>
<A NAME="06"></A>
<H3>18.3.1  Self-Classify</H3>
Consider the problem of finding the counts
of letters occurring in a string (the
frequency-distribution of letters).
Here is one approach.
<p>
We form a table testing each letter for equality 
with the nub.
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>y =: 'hook'</TT></TD>
<TD><TT>nub y</TT></TD>
<TD><TT>(nub y)  =/  y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>hook</TT></TD>
<TD><TT>hok</TT></TD>
<TD><TT>1 0 0 0<BR>
0 1 1 0<BR>
0 0 0 1</TT></TD>
</TABLE>
<p>
The expression <TT>((nub y) = / y)</TT> can be abbreviated as <TT>(= y)</TT>. 
The monadic case of the built-in verb <TT>=</TT> is called 
"Self-classify"). 
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>y</TT></TD>
<TD><TT>nub y</TT></TD>
<TD><TT>(nub y)  =/  y</TT></TD>
<TD><TT>= y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>hook</TT></TD>
<TD><TT>hok</TT></TD>
<TD><TT>1 0 0 0<BR>
0 1 1 0<BR>
0 0 0 1</TT></TD>
<TD><TT>1 0 0 0<BR>
0 1 1 0<BR>
0 0 0 1</TT></TD>
</TABLE>
<p>
If we sum each row of <TT>= y</TT> we obtain
the counts, in the order of the letters in the nub.
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>y</TT></TD>
<TD><TT>= y</TT></TD>
<TD><TT>+/ " 1 =y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>hook</TT></TD>
<TD><TT>1 0 0 0<BR>
0 1 1 0<BR>
0 0 0 1</TT></TD>
<TD><TT>1 2 1</TT></TD>
</TABLE>
<p>
The counts can be paired with the letters of the
nub:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>y</TT></TD>
<TD><TT>nub y</TT></TD>
<TD><TT>(nub y) ;" 0  (+/ " 1 =y)</TT></TD>
<TR VALIGN=TOP>
<TD><TT>hook</TT></TD>
<TD><TT>hok</TT></TD>
<TD><TT>+-+-+<BR>
|h|1|<BR>
+-+-+<BR>
|o|2|<BR>
+-+-+<BR>
|k|1|<BR>
+-+-+</TT></TD>
</TABLE>
<p>
<H3>18.3.2  Classification Schemes</H3>
Gardeners classify soil-types as acid, neutral or 
alkaline, depending on the pH value. Suppose
that a pH less than 6 is classed as acid,  
6 to 7 is neutral, and more than 7 as alkaline.
Here now is a verb to classify a pH value,
returning <TT>A</TT> for acid, <TT>N</TT> for neutral and <TT>L</TT> for alkaline (or limy).
<PRE>
   classify =: ({ & 'ANL')  @: ((>: & 6) + (> & 7))
</PRE>
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>classify 6</TT></TD>
<TD><TT>classify 4.8 5.1 6 7 7.1 8</TT></TD>
<TR VALIGN=TOP>
<TD><TT>N</TT></TD>
<TD><TT>AANNLL</TT></TD>
</TABLE>
<p>
The <TT>classify</TT> function we can regard as defining a 
classification scheme. 
The letters <TT>ANL</TT>, which are in effect
names of classes, are called the keys of the scheme.
<A NAME="07"></A>
<H3>18.3.3  The Key Adverb</H3>
Given some data (a list, say), we can classify each item
to produce a list of corresponding keys. 
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>data =: 7 5 6 4 8</TT></TD>
<TD><TT>k =: classify data</TT></TD>
<TR VALIGN=TOP>
<TD><TT>7 5 6 4 8</TT></TD>
<TD><TT>NANAL</TT></TD>
</TABLE>
<p>
We can select and group together all the data in, 
say, class <TT>A</TT> (all the data with key <TT>A</TT>): 
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>data</TT></TD>
<TD><TT>k</TT></TD>
<TD><TT>k = 'A'</TT></TD>
<TD><TT>(k = 'A') # data</TT></TD>
<TR VALIGN=TOP>
<TD><TT>7 5 6 4 8</TT></TD>
<TD><TT>NANAL</TT></TD>
<TD><TT>0 1 0 1 0</TT></TD>
<TD><TT>5 4</TT></TD>
</TABLE>
<p>
Now suppose we wish to count the items in each class. 
That is, we aim to apply the monadic verb <TT>#</TT> separately
to each group of items all of the same key. 
 To do this we can use the built-in adverb <TT>/.</TT> (slash dot, called "Key"). 
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>data</TT></TD>
<TD><TT>k =: classify data</TT></TD>
<TD><TT>k # /. data</TT></TD>
<TR VALIGN=TOP>
<TD><TT>7 5 6 4 8</TT></TD>
<TD><TT>NANAL</TT></TD>
<TD><TT>2 2 1</TT></TD>
</TABLE>
<p>
For another example, instead of counting the members
we could exhibit the members, by applying the box verb <TT><</TT>.
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>data</TT></TD>
<TD><TT>k =: classify data</TT></TD>
<TD><TT>k < /. data</TT></TD>
<TR VALIGN=TOP>
<TD><TT>7 5 6 4 8</TT></TD>
<TD><TT>NANAL</TT></TD>
<TD><TT>+---+---+-+<BR>
|7 6|5 4|8|<BR>
+---+---+-+</TT></TD>
</TABLE>
<p>
The verb we apply can discover for itself the class of 
each separate argument, 
by classifying the first member: 
Here the verb <TT>u</TT>
produces a boxed list: the key and count:
<PRE>
   u =: (classify @: {.) ; #
   
</PRE>
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>data</TT></TD>
<TD><TT>k =: classify data</TT></TD>
<TD><TT>k u /. data</TT></TD>
<TR VALIGN=TOP>
<TD><TT>7 5 6 4 8</TT></TD>
<TD><TT>NANAL</TT></TD>
<TD><TT>+-+-+<BR>
|N|2|<BR>
+-+-+<BR>
|A|2|<BR>
+-+-+<BR>
|L|1|<BR>
+-+-+</TT></TD>
</TABLE>
<p>
The general scheme for the "Key" adverb is as follows.
In the expression <TT>x u /. y</TT>, we take <TT>y</TT> to be a list,
and <TT>x</TT> is a list of keys of corresponding items of <TT>y</TT> according
to some classification scheme, 
and <TT>u</TT> is the verb to be applied separately to each class.
The scheme is:
<PRE>
              x u /. y    means   (= x) (u @ #) y
</PRE>
To illustrate:
<PRE>
   y =: 4 5 6 7 8 
   x =: classify y
   u =: <
</PRE>
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>y</TT></TD>
<TD><TT>x</TT></TD>
<TD><TT>= x</TT></TD>
<TD><TT>(= x) (u @ #)  y</TT></TD>
<TD><TT>x u /. y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>4 5 6 7 8</TT></TD>
<TD><TT>AANNL</TT></TD>
<TD><TT>1 1 0 0 0<BR>
0 0 1 1 0<BR>
0 0 0 0 1</TT></TD>
<TD><TT>+---+---+-+<BR>
|4 5|6 7|8|<BR>
+---+---+-+</TT></TD>
<TD><TT>+---+---+-+<BR>
|4 5|6 7|8|<BR>
+---+---+-+</TT></TD>
</TABLE>
<p>
We see that each row of <TT>=x</TT> selects items from <TT>y</TT>,
and <TT>u</TT> is applied to this selection. 
<H3>18.3.4  Letter-Counts Revisited</H3>
Recall the example of finding the counts of letters in a string.
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>y =: 'LETTUCE'</TT></TD>
<TD><TT>= y</TT></TD>
<TD><TT>(nub y) ; " 0  +/ "1 (= y)</TT></TD>
<TR VALIGN=TOP>
<TD><TT>LETTUCE</TT></TD>
<TD><TT>1 0 0 0 0 0 0<BR>
0 1 0 0 0 0 1<BR>
0 0 1 1 0 0 0<BR>
0 0 0 0 1 0 0<BR>
0 0 0 0 0 1 0</TT></TD>
<TD><TT>+-+-+<BR>
|L|1|<BR>
+-+-+<BR>
|E|2|<BR>
+-+-+<BR>
|T|2|<BR>
+-+-+<BR>
|U|1|<BR>
+-+-+<BR>
|C|1|<BR>
+-+-+</TT></TD>
</TABLE>
<p>
Here is a variation. We note that
we have in effect a classification scheme where 
we have as many different classes as different letters: each letter
is (the key of) its own class. Thus we can write an
expression of the form <TT>y u /. y</TT>. 
<p>
The applied verb <TT>u</TT> will see, each time, a list of letters, all the same. 
It counts them, with <TT>#</TT>,
 and takes the first, with <TT>{.</TT>,  to be a label for the class.
<PRE>
   u =: {. ; #
</PRE>
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>y</TT></TD>
<TD><TT>= y</TT></TD>
<TD><TT>y u /. y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>LETTUCE</TT></TD>
<TD><TT>1 0 0 0 0 0 0<BR>
0 1 0 0 0 0 1<BR>
0 0 1 1 0 0 0<BR>
0 0 0 0 1 0 0<BR>
0 0 0 0 0 1 0</TT></TD>
<TD><TT>+-+-+<BR>
|L|1|<BR>
+-+-+<BR>
|E|2|<BR>
+-+-+<BR>
|T|2|<BR>
+-+-+<BR>
|U|1|<BR>
+-+-+<BR>
|C|1|<BR>
+-+-+</TT></TD>
</TABLE>
<p>
<A NAME="08"></A>
<H2>18.4  Relations</H2>
Suppose there are a number of publications,
such as: 
<UL>
<LI>"Pigs"  by Smith, on the subject of pigs</LI>
<LI>"Pets"  by Brown, on cats and dogs </LI>
<LI>"Dogs"  by Smith and James, on dogs </LI>
</UL>
<p>
and we aim to catalog such publications. 
 A suitable data structure for such a catalog might be a table  
relating authors to titles and another
 table relating
titles to subjects. For example:
<p>
<p>
<TABLE CELLPADDING=16>
<TR>
 <TD>
   <TABLE BORDER=1 CELLPADDING=4>
   <TR>  <TH> author </TH>  <TH> title  </TH> </TR>
   <TR>  <TD> Smith  </TD>  <TD> "Pigs" </TD> </TR>
   <TR>  <TD> Brown  </TD>  <TD> "Pets" </TD> </TR>
   <TR>  <TD> Smith  </TD>  <TD> "Dogs" </TD> </TR>
   <TR>  <TD> James  </TD>  <TD> "Dogs" </TD> </TR>
   </TABLE>
 </TD>
 <TD>
   <TABLE BORDER=1 CELLPADDING=4>
   <TR>  <TH> title   </TH>  <TH> subject </TH> </TR>
   <TR>  <TD> "Pigs" </TD>  <TD>  pigs   </TD> </TR>
   <TR>  <TD> "Pets" </TD>  <TD>  dogs   </TD> </TR>
   <TR>  <TD> "Pets" </TD>  <TD>  cats   </TD> </TR>
   <TR>  <TD> "Dogs" </TD> <TD>  dogs   </TD> </TR>
   </TABLE>
 </TD>
</TR>
</TABLE>
Such tables we may call "relations". 
The order of the rows is not significant.
Here,for the sake of simplicity, we will stick to
relations with two columns.
<p>
Now we  choose a representation for our relations.
For a first approach, we choose tables of boxed strings.
The authors-titles relation is:
<PRE>
   ]  AT  =: (". ;. _2) 0 : 0
'Smith'  ; 'Pigs'
'Brown'  ; 'Pets'
'Smith'  ; 'Dogs'
'James'  ; 'Dogs'
)
+-----+----+
|Smith|Pigs|
+-----+----+
|Brown|Pets|
+-----+----+
|Smith|Dogs|
+-----+----+
|James|Dogs|
+-----+----+
</PRE>
and the titles-subjects relation is:
<PRE>
   ] TS =: (". ;. _2) 0 : 0
'Pigs' ; 'pigs'
'Pets' ; 'cats'
'Pets' ; 'dogs'
'Dogs' ; 'dogs'
)
+----+----+
|Pigs|pigs|
+----+----+
|Pets|cats|
+----+----+
|Pets|dogs|
+----+----+
|Dogs|dogs|
+----+----+
   
</PRE>
<A NAME="09"></A>
<H3>18.4.1  Join of Relations</H3>
From the authors-titles relation <TT>AT</TT> and the titles-subjects
relation <TT>TS</TT> we can compute an authors-subjects relation
 showing which author has written a title on which subject.
We say that <TT>AT</TT> and <TT>TS</TT> are to be joined with respect to
 titles, and we would expect the join to look like this:
<PRE>
+-----+----+
|Smith|pigs|
+-----+----+
|Brown|cats|
+-----+----+
|Brown|dogs|
+-----+----+
|Smith|dogs|
+-----+----+
|James|dogs|
+-----+----+
   
</PRE>
The plan for this section is to look at a function for
computing joins, then at an improved version,
and then at the advantage of representing relations
as tables of symbols rather than boxed strings.
Finally we look at some performance comparisons.
<p>
A method is as follows.
We consider all possible pairs consisting of a row 
<TT>at</TT> from table <TT>AT</TT> and a row <TT>ts</TT> from table <TT>TS</TT>.
Each pair <TT>at,ts</TT> is of the form:
<PRE>
          author; title; title; subject
</PRE>
If title matches title, that is, item 1 matches item 2,
then we extract author and subject, that is, items 0 and 3.
Verbs for testing and extracting from <TT>at,ts</TT> pairs  
can be written as:
<PRE>
   test =: 1&{ =  2&{
   extr =: 0 3 & {
</PRE>
and these verbs can be plugged into a suitable 
conjunction to do the pairing. In writing this conjunction,
we aim to avoid requiring the whole set of possible pairs
to be present at the same time, since this set may be large.
We also aim to avoid any duplicates in the result.
Here is a first attempt. 
<PRE>
   PAIR =: 2 : 0
:
z =.  0 0 $ ''
for_at. x do.
   for_ts.  y do.
     if. u at,ts do. z =. z, v at,ts  end.
   end.
end.
~. z
)
</PRE>
The join verb can now be written as: 
<PRE>
   join =: test PAIR extr
</PRE>
and we see:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>AT</TT></TD>
<TD><TT>TS</TT></TD>
<TD><TT> AT join TS</TT></TD>
<TR VALIGN=TOP>
<TD><TT>+-----+----+<BR>
|Smith|Pigs|<BR>
+-----+----+<BR>
|Brown|Pets|<BR>
+-----+----+<BR>
|Smith|Dogs|<BR>
+-----+----+<BR>
|James|Dogs|<BR>
+-----+----+</TT></TD>
<TD><TT>+----+----+<BR>
|Pigs|pigs|<BR>
+----+----+<BR>
|Pets|cats|<BR>
+----+----+<BR>
|Pets|dogs|<BR>
+----+----+<BR>
|Dogs|dogs|<BR>
+----+----+</TT></TD>
<TD><TT>+-----+----+<BR>
|Smith|pigs|<BR>
+-----+----+<BR>
|Brown|cats|<BR>
+-----+----+<BR>
|Brown|dogs|<BR>
+-----+----+<BR>
|Smith|dogs|<BR>
+-----+----+<BR>
|James|dogs|<BR>
+-----+----+</TT></TD>
</TABLE>
<p>
The <TT>join</TT> verb as defined above is slow, because
the <TT>test</TT> and <TT>extr</TT> verbs are applied to a single <TT>x,y</TT> pair at
a time - they are scalar computations.  Performance will
be better if we can give these verbs as much data as 
possible to work on at one time. (This is a universal rule in J).
Vector 
or array arguments are better.  Here is a revised
vector-oriented version of <TT>PAIR</TT> and <TT>join</TT>, which still
avoids building the entire set of pairs.
<PRE>
   VPAIR =: 2 : 0
:
z =.  0 0 $ ''
for_at. x do.
      z =. z , |: v (#~"1  u) |: at , "1 y
end.
~. z
)
   
   vjoin  =: test VPAIR extr 
   
</PRE>
giving the same result as before:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>AT join TS</TT></TD>
<TD><TT>AT vjoin TS</TT></TD>
<TR VALIGN=TOP>
<TD><TT>+-----+----+<BR>
|Smith|pigs|<BR>
+-----+----+<BR>
|Brown|cats|<BR>
+-----+----+<BR>
|Brown|dogs|<BR>
+-----+----+<BR>
|Smith|dogs|<BR>
+-----+----+<BR>
|James|dogs|<BR>
+-----+----+</TT></TD>
<TD><TT>+-----+----+<BR>
|Smith|pigs|<BR>
+-----+----+<BR>
|Brown|cats|<BR>
+-----+----+<BR>
|Brown|dogs|<BR>
+-----+----+<BR>
|Smith|dogs|<BR>
+-----+----+<BR>
|James|dogs|<BR>
+-----+----+</TT></TD>
</TABLE>
<p>
Representing relations as tables of boxed strings,
as above, is less than efficient.
For a repeated value, the entire string is repeated. 
Values are compared by comparing entire strings.
<p>
Now we look at another possibility. Rather than boxed strings,
a relation can be represented by a table of
 symbols.
<A NAME="10"></A>
<H3>18.4.2   What are Symbols?</H3>
Symbols are for efficient computation with string data.
Symbols are a distinct data-type, in the same way
that characters, boxes and numbers are distinct data-types.
A symbol is a scalar which identifies, or refers to,
a string. 
<p>
A symbol can be created by applying the built-in verb
<TT>s:</TT> (lowercase s colon) to a boxed string.
<PRE>
   a  =: s: <'hello'
</PRE>
Now the variable <TT>a</TT> has a value of type symbol. We inspect
this value in the usual way:
<PRE>
   a
`hello
</PRE>
and see that the value is displayed
as the original string preceded by a left-quote.
Even though <TT>a</TT> looks like a string when displayed, 
it is a scalar.
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>a</TT></TD>
<TD><TT>$ a</TT></TD>
<TD><TT># $ a</TT></TD>
<TR VALIGN=TOP>
<TD><TT>`hello</TT></TD>
<TD><TT>&nbsp;</TT></TD>
<TD><TT>0</TT></TD>
</TABLE>
<p>
The original string is stored in a data-structure, 
maintained automatically by the J system, called the 
symbol-table.
Strings are not duplicated within the symbol-table. 
Hence  if another symbol <TT>b</TT> is created from the same string as <TT>a</TT>,
then <TT>b</TT> is equal to <TT>a</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>a</TT></TD>
<TD><TT>b =: s: <'hello'</TT></TD>
<TD><TT>b = a</TT></TD>
<TR VALIGN=TOP>
<TD><TT>`hello</TT></TD>
<TD><TT>`hello</TT></TD>
<TD><TT>1</TT></TD>
</TABLE>
<p>
Notice that the comparison is simple scalar equality, with
no need to compare the original strings.
<p>
Our relations above can be converted to arrays of 
symbols, and joined as before.
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>sAT =: s: AT</TT></TD>
<TD><TT>sTS =: s: TS</TT></TD>
<TD><TT>sAT vjoin sTS</TT></TD>
<TR VALIGN=TOP>
<TD><TT>`Smith `Pigs<BR>
`Brown `Pets<BR>
`Smith `Dogs<BR>
`James `Dogs</TT></TD>
<TD><TT>`Pigs `pigs<BR>
`Pets `cats<BR>
`Pets `dogs<BR>
`Dogs `dogs</TT></TD>
<TD><TT>`Smith `pigs<BR>
`Brown `cats<BR>
`Brown `dogs<BR>
`Smith `dogs<BR>
`James `dogs</TT></TD>
</TABLE>
<p>
Symbols are lexicographically ordered to reflect the ordering
of the original strings. Hence
tables  of symbols can be sorted:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>sAT</TT></TD>
<TD><TT> /:~ sAT</TT></TD>
<TR VALIGN=TOP>
<TD><TT>`Smith `Pigs<BR>
`Brown `Pets<BR>
`Smith `Dogs<BR>
`James `Dogs</TT></TD>
<TD><TT>`Brown `Pets<BR>
`James `Dogs<BR>
`Smith `Dogs<BR>
`Smith `Pigs</TT></TD>
</TABLE>
<p>
<H3>18.4.3  Measurements Compared</H3>
Here is a utility verb giving time in seconds 
to evaluate an expression,
averaged over say 4 executions.
<PRE>
   time =: (8j5 & ":) @: (4 & (6!:2))
</PRE>
The examples of relations above are too small
for meaningful  performance measurements,
 so we make larger relations
by replicating each say 100 times.
<PRE>
   AT  =: 100 $ AT
   TS  =: 100 $ TS
   sAT =: 100 $ sAT
   sTS =: 100 $ sTS
</PRE>
There are 4 cases to compare:
<PRE>
   t1 =: time 'AT  join  TS'   NB. scalar method, boxed strings
   t2 =: time 'sAT join  sTS'  NB. scalar method, symbols
   t3 =: time 'AT  vjoin TS'   NB. vector method, boxed strings
   t4 =: time 'sAT vjoin sTS'  NB. vector method, symbols
</PRE>
and we see: 
<PRE>
   3 3 $ ' '; 'strings'; 'symbols';'scalar';t1;t2; 'vector';t3;t4
+------+--------+--------+
|      |strings |symbols |
+------+--------+--------+
|scalar| 1.79959| 0.04626|
+------+--------+--------+
|vector| 0.02485| 0.00202|
+------+--------+--------+
   
</PRE>
<A NAME="11"></A>
<H3>18.4.4  Saving and Restoring the Symbol Table</H3>
Suppose that <TT>data</TT> is an array of symbols.
<PRE>
   ] data =: s: 2 2 $ 'hello'; 'blah';'blah';'goodbye'
`hello `blah   
`blah  `goodbye
</PRE>
For a symbol in <TT>data</TT> its original string (<TT>'hello'</TT> for example) is stored 
only in the symbol table, not in <TT>data</TT> itself.  The original string is needed
to display the value of the symbol.
<p>
Suppose that we write <TT>data</TT> to a file, aiming to
read it back in a new session. At the beginning of a 
new session, the symbol table is empty.
Thus we must save the symbol table from the earlier 
session, and reinstate it at the beginning of the new session.
<p>
First, here are two utility functions to save a value to a file
and retrieve it. (See <A HREF="27.htm">Chapter 27</A> and
 <A HREF="28.htm">Chapter 28</A> for more about data in files.)
<PRE>
   save =: 4 : '(3!:1 x ) 1!:2 < y '
   retr =: 3 : '3!:2 (1!:1 < y )'
</PRE>
Save the data to a file named, say, <TT>data.xyz</TT>
<PRE>
   data save 'data.xyz'
</PRE>
The symbol table is not itself a variable, 
but the expression <TT>0 s: 10</TT> gives a value for it. 
We save this value to a file named, say, <TT>symtab.xyz</TT>
<PRE>
   (0 s: 10) save 'symtab.xyz'
</PRE>
Start a new J session. The symbol table is initially empty, so begin by 
reinstating it from the file saved in the earlier session:
<PRE>
   10 s: (retr 'symtab.xyz')
1
   
</PRE>
Now, with the correct symbol table in place, 
we can retrieve the array of symbols <TT>data</TT> from its file:
<PRE>
   DATA =: retr 'data.xyz'
</PRE>
and we see that the symbols are correctly interpreted:
<PRE>
   DATA
`hello `blah   
`blah  `goodbye
</PRE>
This is the end of Chapter 18
  </tr> </table> 
<HR>  
 <p ALIGN=CENTER> 
 <A HREF="19.htm"> NEXT </A> <BR> 
 <A HREF="contents.htm#toc"> Table of Contents </A> <BR> 
<A HREF="kwic.htm"> Index </A> 
<HR> 
<P ALIGN=CENTER> 
<FONT SIZE=-1>The examples in this chapter 
were executed using J version  j701/beta/2010-11-24/22:45. 
 This chapter last updated 22 Dec 2010<BR> 
Copyright &copy; Roger Stokes 2010. 
 This material may be freely reproduced, 
provided that this copyright notice is also reproduced. 
</FONT> 
 <!--bottom jump start--><hr><a href="19.htm">&gt;&gt;</a>&nbsp;
<a href="17.htm">&lt;&lt;</a>&nbsp;
<a href="../user/contents.htm">Usr</a>&nbsp;
<a href="../primer/contents.htm">Pri</a>&nbsp;
<a href="../jforc/contents.htm">JfC</a>&nbsp;
<a href="../learning/contents.htm">LJ</a>&nbsp;
<a href="../phrases/contents.htm">Phr</a>&nbsp;
<a href="../dictionary/contents.htm">Dic</a>&nbsp;
<a href="../release/contents.htm">Rel</a>&nbsp;
<a href="../dictionary/vocabul.htm">Voc</a>&nbsp;
<a href="../dictionary/xmain.htm">!:</a>&nbsp;
<a href="../index.htm">Help</a>&nbsp;
Learning J<!--bottom jump end--></BODY> 
 </HTML> 
 
