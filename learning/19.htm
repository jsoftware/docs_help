<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
        <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=ISO-8859-1">
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.9.118  (Win32)">
	<META NAME="CREATED" CONTENT="20051014;16001218">
	<META NAME="CHANGED" CONTENT="20051014;16020434">
	
        <title>Ch 19: Numbers</title>

        <STYLE TYPE="text/css">
        <!--
         TT  {font-size: 11pt; COLOR: BLUE}
         PRE {font-size: 11pt; COLOR: BLUE}
         -->
         </STYLE>
</HEAD>



<BODY BGCOLOR=WHITE><!--top jump start--><a href="20.htm">&gt;&gt;</a>&nbsp;
<a href="18.htm">&lt;&lt;</a>&nbsp;
<a href="../user/contents.htm">Usr</a>&nbsp;
<a href="../primer/contents.htm">Pri</a>&nbsp;
<a href="../jforc/contents.htm">JfC</a>&nbsp;
<a href="../learning/contents.htm">LJ</a>&nbsp;
<a href="../phrases/contents.htm">Phr</a>&nbsp;
<a href="../dictionary/contents.htm">Dic</a>&nbsp;
<a href="../release/contents.htm">Rel</a>&nbsp;
<a href="../dictionary/vocabul.htm">Voc</a>&nbsp;
<a href="../dictionary/xmain.htm">!:</a>&nbsp;
<a href="../index.htm">Help</a>&nbsp;
Learning J<hr><!--top jump end-->
<table border="0" cellpadding="5" cellspacing="0"  width="100%">
 <tr> <td valign="top" width="17%"> <p> </td>
      <td valign="top" width="83%"> 
<A NAME="01"></A><H1>Chapter 19: Numbers</H1>
<p>
The topics covered in this chapter are: 
<UL> 
<LI>The different kinds of numbers available in J 
<LI>Special numbers (infinities and indeterminates) 
<LI>Notations for writing numbers 
<LI>How numbers are displayed 
<LI>Random numbers </LI> 
</UL> 
<H2>19.1  Six Different Kinds of Numbers</H2>
<p>
J supports computation with numbers of these kinds: 
<p>
<UL> 
<LI> booleans (or truth-values) 
<LI>integers 
<LI>real (or floating-point) numbers 
<LI>complex numbers 
<LI>extended integers (that is, arbitrarily large integers exactly represented) 
<LI>rationals (that is, pairs of extended integers) 
</UL> 
<p>
Each kind of number has its own internal representation in 
 memory. For example, 
an array containing only the truth-values <TT>0</TT> and <TT>1</TT> 
is stored in a compact internal form, called "boolean", 
rather  
than in the floating-point form.  
Similarly an array containing only (relatively small) 
whole numbers is stored in a compact form   
called "integer".   
<p>
The choice of appropriate representation 
is managed entirely automatically by the J system,  
and is not normally something the programmer must be aware of. 
However, there is a means of testing 
the representation of a number.  Here is a utility function for the purpose. 
<PRE>
   types =: 'bool';'int';'float';'complex';'ext int';'rational'
   
   type  =: > @: ({ & types) @: (1 4 8 16 64 128 & i.) @: (3 !: 0)
   
</PRE>
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>type 0=0</TT></TD> 
<TD><TT>type 37</TT></TD> 
<TD><TT>type 2.5</TT></TD> 
<TD><TT>type 12345678901</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>bool</TT></TD> 
<TD><TT>int</TT></TD> 
<TD><TT>float</TT></TD> 
<TD><TT>float</TT></TD> 
</TABLE> 
<A NAME="02"></A><H3>19.1.1  Booleans</H3>
<p>
There are built-in functions for logical computation with 
boolean values.  
Giving conventional names to these functions: 
<PRE>
   and    =: *.
   or     =: +.
   not    =: -.
   notand =: *: 
   notor  =: +:
</PRE>
<p>
we can show their truth-tables: 
<PRE>
   p =: 4 1 $ 0 0 1 1
   q =: 4 1 $ 0 1 0 1
   
</PRE>
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>p </TT></TD> 
<TD><TT>q </TT></TD> 
<TD><TT>p and q</TT></TD> 
<TD><TT>p or q</TT></TD> 
<TD><TT>not p</TT></TD> 
<TD><TT>p notand q</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>0<BR> 
0<BR> 
1<BR> 
1</TT></TD> 
<TD><TT>0<BR> 
1<BR> 
0<BR> 
1</TT></TD> 
<TD><TT>0<BR> 
0<BR> 
0<BR> 
1</TT></TD> 
<TD><TT>0<BR> 
1<BR> 
1<BR> 
1</TT></TD> 
<TD><TT>1<BR> 
1<BR> 
0<BR> 
0</TT></TD> 
<TD><TT>1<BR> 
1<BR> 
1<BR> 
0</TT></TD> 
</TABLE> 
<p>
Further logical functions can be defined in the usual way. 
For example, logical implication, with the scheme 
<PRE>
     p implies q    means   not (p and not q)
   
</PRE>
<p>
is defined by <TT>not</TT> composed with the hook <TT>and not</TT> 
<PRE>
   implies =: not @ (and not)
   
</PRE>
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>p</TT></TD> 
<TD><TT>q</TT></TD> 
<TD><TT>p implies q</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>0<BR> 
0<BR> 
1<BR> 
1</TT></TD> 
<TD><TT>0<BR> 
1<BR> 
0<BR> 
1</TT></TD> 
<TD><TT>1<BR> 
1<BR> 
0<BR> 
1</TT></TD> 
</TABLE> 
<A NAME="03"></A><p>
We regard the booleans as numbers because they can 
be interpreted as having arithmetic values. To illustrate, 
implication has the same truth-table as  
less-than-or-equal: 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>p implies q</TT></TD> 
<TD><TT>p <: q</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>1<BR> 
1<BR> 
0<BR> 
1</TT></TD> 
<TD><TT>1<BR> 
1<BR> 
0<BR> 
1</TT></TD> 
</TABLE> 
<p>
For another example of booleans as numbers, 
the sum of the positive numbers in a list is shown by: 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>z =: 3 _1 4</TT></TD> 
<TD><TT>b =: z > 0</TT></TD> 
<TD><TT>b * z</TT></TD> 
<TD><TT>+/ b * z</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>3 _1 4</TT></TD> 
<TD><TT>1 0 1</TT></TD> 
<TD><TT>3 0 4</TT></TD> 
<TD><TT>7</TT></TD> 
</TABLE> 
<A NAME="04"></A><H3>19.1.2  Integers</H3>
<p>
On a 32-bit machine integers range between 
<TT>_2147483648</TT> and <TT>2147483647</TT>. 
<p>
The result of arithmetic with integers is converted to 
floating-point if larger than the maximum integer. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>maxint=:2147483647 </TT></TD> 
<TD><TT>type maxint</TT></TD> 
<TD><TT>z =: 1+maxint</TT></TD> 
<TD><TT>type z</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>2147483647</TT></TD> 
<TD><TT>int</TT></TD> 
<TD><TT>2.14748e9</TT></TD> 
<TD><TT>float</TT></TD> 
</TABLE> 
<A NAME="05"></A><H3>19.1.3  Floating-Point Numbers</H3>
<p>
A floating-point number is a number represented in the computer in such a way that: 
(1) there may be a a fractional part as well as a whole-number part. 
(2) a fixed amount of computer storage is occupied by the number, whatever the value of the number. 
and therefore (3) the precision with which the number is represented is limited to  
at most about 17 significant decimal digits (on a PC). 
<p>
Examples of floating-point numbers are <TT>0.25 2.5 12345678901</TT> 
<p>
We will use the term "real" more or less interchangeably with "floating-point". 
<p>
<H3>19.1.4  Scientific Notation</H3>
<p>
What is sometimes called "scientific notation" 
is a convenient way of writing  
very large or very small numbers.  
For example, 1500000 may be written as <TT>1.5e6</TT>, 
 meaning <TT>1.5 * 10^6</TT>.  
The general scheme is that a number written in the form <TT>XeY</TT>, where <TT>Y</TT> is a 
(positive or negative) integer means <TT>(X * 10^Y)</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>3e2</TT></TD> 
<TD><TT>1.5e6</TT></TD> 
<TD><TT>1.5e_4</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>300</TT></TD> 
<TD><TT>1500000</TT></TD> 
<TD><TT>0.00015</TT></TD> 
</TABLE> 
<p>
Note that in <TT>3e2</TT> the letter <TT>e</TT> is not any kind of function;  
it is part of the notation for writing numbers,  
just as a decimal point is part of the notation.  
<p>
We say that the string of characters <TT>3</TT> followed by <TT>e</TT> followed by <TT>2</TT> is a numeral 
which denotes the number <TT>300</TT>.   
The string of characters <TT>3</TT> followed by <TT>0</TT>  
followed by <TT>0</TT> is another numeral denoting the same number.  
Different forms of numerals provide convenient ways to express  
different numbers.  A number expressed by a numeral is also called a "constant" 
(as opposed to a variable.) 
<p>
We will come back to the topic of numerals: now we return to the topic 
of different kinds of numbers. 
<A NAME="06"></A><H3>19.1.5  Comparison of Floating-Point Numbers</H3>
<p>
Two numbers are regarded as equal if their difference is relatively small. 
For example, we see that <TT>a</TT> and <TT>b</TT> have a non-zero difference, 
but even so the expression <TT>a = b</TT> produces "true". 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>a =: 1.001</TT></TD> 
<TD><TT>b =: a - 2^_45</TT></TD> 
<TD><TT>a - b</TT></TD> 
<TD><TT>a = b</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>1.001</TT></TD> 
<TD><TT>1.001</TT></TD> 
<TD><TT>2.84217e_14</TT></TD> 
<TD><TT>1</TT></TD> 
</TABLE> 
<p>
If we say that the "relative difference" of two numbers is  
the magnitude of the difference divided by the larger of the magnitudes: 
<PRE>
   RD =: (| @: -) % (>. &: |)
</PRE>
<p>
then for <TT>a=b</TT> to be true, the relative difference  
<TT>(a RD b)</TT> must not exceed a small value 
called the "comparison tolerance" which is by default <TT>2^_44</TT> 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>a RD b</TT></TD> 
<TD><TT>2^_44</TT></TD> 
<TD><TT>a = b</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>2.83933e_14</TT></TD> 
<TD><TT>5.68434e_14</TT></TD> 
<TD><TT>1</TT></TD> 
</TABLE> 
<p>
Thus to compare two numbers we need to compare relative difference with tolerance. 
The latter comparison is itself strict, that is, does not involve any tolerance. 
<p>
Zero is not tolerantly equal to 
any non-zero number, no matter how small, 
because the relative difference must be 
<TT>1</TT>, and thus greater than tolerance. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>tiny =: 1e_300</TT></TD> 
<TD><TT>tiny = 0</TT></TD> 
<TD><TT>tiny RD 0</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>1e_300</TT></TD> 
<TD><TT>0</TT></TD> 
<TD><TT>1</TT></TD> 
</TABLE> 
<p>
However, <TT>1+tiny</TT> is tolerantly equal to <TT>1</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>tiny</TT></TD> 
<TD><TT>tiny = 0</TT></TD> 
<TD><TT>1 = tiny + 1</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>1e_300</TT></TD> 
<TD><TT>0</TT></TD> 
<TD><TT>1</TT></TD> 
</TABLE> 
<p>
The value of the comparison tolerance currently in effect  
is given by the built-in verb  
<TT>9!:18</TT> applied to a null argument. It is currently <TT>2^_44</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>9!:18 '' </TT></TD> 
<TD><TT>2^_44</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>5.68434e_14</TT></TD> 
<TD><TT>5.68434e_14</TT></TD> 
</TABLE> 
<p>
Applying the built-in 
verb <TT>9!:19</TT> to an argument <TT>y</TT> sets the tolerance to <TT>y</TT> 
subsequently. 
The following example shows that when the  
tolerance is <TT>2^_44</TT>, then 
<TT>a = b</TT> but when the tolerance is set to zero  
it is no longer the case that <TT>a = b</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>(9!:19) 2^_44 </TT></TD> 
<TD><TT>a = b</TT></TD> 
<TD><TT>(9!:19) 0</TT></TD> 
<TD><TT>a = b</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>&nbsp;</TT></TD> 
<TD><TT>1</TT></TD> 
<TD><TT>&nbsp;</TT></TD> 
<TD><TT>0</TT></TD> 
</TABLE> 
<p>
The tolerance queried by <TT>9!:18</TT> and set by <TT>9!:19</TT> is a global 
parameter, influencing the outcome of computations with <TT>=</TT>.   
A verb to apply a specified tolerance <TT>t</TT>, regardless of the global parameter, 
can be written as <TT>= !. t</TT>.  For example, strict (zero-tolerance) equality 
can be defined by: 
<PRE>
   streq =: = !.  0
</PRE>
<p>
Resetting the global tolerance to the default value, we see: 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>(9!:19) 2^_44 </TT></TD> 
<TD><TT>a - b</TT></TD> 
<TD><TT>a = b</TT></TD> 
<TD><TT>a streq b</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>&nbsp;</TT></TD> 
<TD><TT>2.84217e_14</TT></TD> 
<TD><TT>1</TT></TD> 
<TD><TT>0</TT></TD> 
</TABLE> 
<p>
Comparison with <TT>=</TT> is tolerant,  
and so are comparisons with <TT><, <:, >, >:, ~:</TT> and <TT>-:</TT>. 
For example, the difference <TT>a-b</TT> is positive but too small to make it true that 
<TT>a>b</TT> 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>a - b</TT></TD> 
<TD><TT>a > b</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>2.84217e_14</TT></TD> 
<TD><TT>0</TT></TD> 
</TABLE> 
<p>
Permissible tolerances range between <TT>0</TT> and <TT>2^_35</TT>.   
That is, an attempt to set the tolerance larger 
than <TT>2^_35</TT> is an error: 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>(9!:19) 2^_35</TT></TD> 
<TD><TT>(9!:19) 2^_34</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>&nbsp;</TT></TD> 
<TD><TT>error</TT></TD> 
</TABLE> 
<p>
The effect of disallowing large tolerances  
is that no two different integers compare equal when  
converted to floating-point. 
<A NAME="07"></A><H3>19.1.6  Complex Numbers</H3>
<p>
The square root of -1 is the imaginary number conventionally  
called "i". 
A complex number which is conventionally  written as,  
for example, 3+i4 is in J written as <TT>3j4</TT>.   
<p>
In J an imaginary number is represented as a  
complex number with real part zero. 
Thus "i", the square root of -1, can be  
written <TT>0j1</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>i =: %: _1</TT></TD> 
<TD><TT>i * i</TT></TD> 
<TD><TT>0j1 * 0j1</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>0j1</TT></TD> 
<TD><TT>_1</TT></TD> 
<TD><TT>_1</TT></TD> 
</TABLE> 
<p>
A complex number can be built from two separate real numbers by arithmetic 
in the ordinary way,  
or more conveniently with the built-in function <TT>j.</TT> (lowercase j dot, called  
"Complex"). 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>3 + (%: _1) * 4</TT></TD> 
<TD><TT>3 j. 4</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>3j4</TT></TD> 
<TD><TT>3j4</TT></TD> 
</TABLE> 
<p>
Some more examples of arithmetic with complex numbers: 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>2j3 * 5j7</TT></TD> 
<TD><TT>10j21 % 5j7</TT></TD> 
<TD><TT>2j3 % 2</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>_11j29</TT></TD> 
<TD><TT>2.66216j0.472973</TT></TD> 
<TD><TT>1j1.5</TT></TD> 
</TABLE> 
<p>
A complex number such as <TT>3j4</TT> is a single number, a scalar. To extract 
its real part and imaginary part separately we can use the built-in verb 
<TT>+.</TT>(plus dot, called "Real/Imaginary").   
To extract separately the magnitude and angle (in radians) we can use the  
built-in verb <TT>*.</TT> (asterisk dot, called "Length/Angle"). 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>+. 3j4</TT></TD> 
<TD><TT>*. 3j4</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>3 4</TT></TD> 
<TD><TT>5 0.927295</TT></TD> 
</TABLE> 
<p>
Given a magnitude and angle, we can build a complex number 
by taking sine and cosine,  or more conveniently with the built-in 
function <TT>r.</TT> (lowercase r dot, called "Polar"). 
<PRE>
   sin =: 1 & o.
   cos =: 2 & o.
   mag =: 5
   ang =: 0.92729522  NB. radians
</PRE>
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>mag * (cos ang) + 0j1 * sin ang</TT></TD> 
<TD><TT>mag r. ang</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>3j4</TT></TD> 
<TD><TT>3j4</TT></TD> 
</TABLE> 
<p>
A complex constant with magnitude <TT>X</TT> and angle (in radians) <TT>Y</TT> 
can be written in the form 
<TT>XarY</TT>, meaning <TT>X r. Y</TT>. Similarly, if the angle is given in degrees, 
we can write <TT>XadY</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>5ar0.9272952</TT></TD> 
<TD><TT>5ad53.1301</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>3j4</TT></TD> 
<TD><TT>3j4</TT></TD> 
</TABLE> 
<A NAME="08"></A><H3>19.1.7  Extended Integers</H3>
<p>
A floating-point number, having a limited storage space in the computer's memory,  
 can represent an integer exactly only up to about 17 digits.  
For exact computations with longer numbers, "extended integers" are available.  
An "extended integer" is a number which exactly represents an integer no matter how many digits are needed. 
An extended integer is written with the digits followed with the letter 'x'. Compare the following: 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>a =: *: 10000000001</TT></TD> 
<TD><TT>b =: *: 10000000001x</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>1e20</TT></TD> 
<TD><TT>100000000020000000001</TT></TD> 
</TABLE> 
<p>
Here <TT>a</TT> is an approximation while <TT>b</TT> is an exact result. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>type a</TT></TD> 
<TD><TT>type b</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>float</TT></TD> 
<TD><TT>ext int</TT></TD> 
</TABLE> 
<p>
We can see that adding <TT>1</TT> to <TT>a</TT> makes no difference, while adding 1 to <TT>b</TT> does make a difference: 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>(a + 1) - a</TT></TD> 
<TD><TT>(b + 1) - b</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>0</TT></TD> 
<TD><TT>1</TT></TD> 
</TABLE> 
<A NAME="09"></A><H3>19.1.8  Rational Numbers</H3>
<p>
A "rational number" is a single number which represents exactly the ratio of two 
integers, for example, two-thirds is the ratio of 2 to 3.  Two-thirds 
can be written as a rational number with the notation <TT>2r3</TT>. 
<p>
The point of rationals is that they are are exact representations  
using extended integers. Arithmetic with rationals gives exact results. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>2r3 + 1r7</TT></TD> 
<TD><TT>2r3 * 4r7</TT></TD> 
<TD><TT>2r3 % 5r7</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>17r21</TT></TD> 
<TD><TT>8r21</TT></TD> 
<TD><TT>14r15</TT></TD> 
</TABLE> 
<p>
Rationals can be constructed by dividing extended integers. 
Compare the following: 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>2 % 3</TT></TD> 
<TD><TT>2x % 3x</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>0.666667</TT></TD> 
<TD><TT>2r3</TT></TD> 
</TABLE> 
<p>
A rational can be constructed from a given floating-point 
number with the verb <TT>x:</TT> 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>x: 0.3</TT></TD> 
<TD><TT>x: 1 % 3</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>3r10</TT></TD> 
<TD><TT>1r3</TT></TD> 
</TABLE> 
<p>
A rational number can be converted to a floating-point approximation with the inverse of<TT>x:</TT> , that is, verb <TT>x: ^: _1</TT> 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>float =: x: ^: _1</TT></TD> 
<TD><TT>float  2r3</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>+--+--+--+<BR> 
|x:|^:|_1|<BR> 
+--+--+--+</TT></TD> 
<TD><TT>0.666667</TT></TD> 
</TABLE> 
<p>
Given a rational number, its numerator and denominator can 
be recovered with the verb <TT>2 & x:</TT>,  which gives a list of length 2. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>nd =: 2 & x:</TT></TD> 
<TD><TT>nd 2r3</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>+-+-+--+<BR> 
|2|&|x:|<BR> 
+-+-+--+</TT></TD> 
<TD><TT>2 3</TT></TD> 
</TABLE> 
<H3>19.1.9  Type Conversion</H3>
<p>
We have numbers of six different types: 
boolean, integer, extended integer, rational, floating-point and complex. 
<p>
Arithmetic can be done with a mixture of types. 
For example an integer plus an extended gives an extended,  
and a rational times a float gives a float. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>1 + 10^19x</TT></TD> 
<TD><TT>1r3 * 0.75</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>10000000000000000001</TT></TD> 
<TD><TT>0.25</TT></TD> 
</TABLE> 
<p>
The general scheme is that the six types 
 form a progression: from boolean  
to integer to extended to rational to floating-point to complex. 
We say that boolean is the simplest or "lowest" type 
and complex as the most general or "highest" type 
<p>
Where we have two numbers of different types, 
the one of lower type is converted to match the type of the higher. 
and the result is of the "higher". 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>type 1r3</TT></TD> 
<TD><TT>type 1%3</TT></TD> 
<TD><TT>z =: 1r3, 1%3</TT></TD> 
<TD><TT>type z</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>rational</TT></TD> 
<TD><TT>float</TT></TD> 
<TD><TT>0.333333 0.333333</TT></TD> 
<TD><TT>float</TT></TD> 
</TABLE> 
<H2>19.2  Special Numbers</H2>
<A NAME="10"></A><H3>19.2.1  "Infinity"</H3>
<p>
A floating-point number can (on a PC) be no larger than about 1e308, 
because of the way it is stored in the computer's memory. 
Any arithmetic which attempts to produce a larger result 
will in fact produce a special number called "infinity" 
and written <TT>_</TT> (underscore). For example: 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>1e308 * 0 1 2</TT></TD> 
<TD><TT>1e400</TT></TD> 
<TD><TT>1 % 0</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>0 1e308 _</TT></TD> 
<TD><TT>_</TT></TD> 
<TD><TT>_</TT></TD> 
</TABLE> 
<p>
There is also 
 "negative infinity" written as <TT>__</TT> (underscore underscore). 
Infinity is a floating-point number: 
<PRE>
   type _
float
   
<A NAME="11"></A></PRE>
<H3>19.2.2  Indeterminate Numbers</H3>
<p>
Infinity is equal to infinity.  
However, infinity minus infinity is 
not zero but rather a special number called  
"indeterminate",  
written as <TT>_.</TT> (underscore dot) 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>_ = _</TT></TD> 
<TD><TT>_ - _</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>1</TT></TD> 
<TD><TT>_.</TT></TD> 
</TABLE> 
<p>
Indeterminate is equal to indeterminate. 
However indeterminate minus indeterminate 
is not zero but indeterminate. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>_. = _.</TT></TD> 
<TD><TT>_. - _.</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>1</TT></TD> 
<TD><TT>_.</TT></TD> 
</TABLE> 
<p>
Computations with indeterminate may  
produce surprising results. 
Thus indeterminate is not to be regarded as extending  
the meaning of "number" according to 
some extended axiomatization of arithmetic. 
  
Rather, the view is recommended 
that the only purpose of indeterminate 
is as a signal of numerical error when it occurs in the  
result of a computation. 
<p>
Infinity is equal to itself and  
nothing else, and the same is true of 
indeterminate. Thus we have a reliable (that is, 
determinate) test for occurrences. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>z =: 1 _ _.</TT></TD> 
<TD><TT>z = 1</TT></TD> 
<TD><TT>z = _</TT></TD> 
<TD><TT>z = _.</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>1 _ _.</TT></TD> 
<TD><TT>1 0 0</TT></TD> 
<TD><TT>0 1 0</TT></TD> 
<TD><TT>0 0 1</TT></TD> 
</TABLE> 
<A NAME="12"></A><H2>19.3  Notations for Numerals</H2>
<p>
We have seen above numerals formed with the letters <TT>e</TT>, <TT>r</TT> and <TT>j</TT>, for example: 
<TT>1e3</TT>, <TT>2r3</TT>, and <TT>3j4</TT>. Here we look at more letters for forming numerals. 
<p>
A numeral written with letter <TT>p</TT>, of the form <TT>XpY</TT>  means <TT>X * pi ^ Y</TT>  
where <TT>pi</TT> is the familiar value 3.14159265.... 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>pi =: 1p1</TT></TD> 
<TD><TT>twopi =: 2p1</TT></TD> 
<TD><TT>2p_1</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>3.14159</TT></TD> 
<TD><TT>6.28319</TT></TD> 
<TD><TT>0.63662</TT></TD> 
</TABLE> 
<p>
Similarly, a numeral written with letter <TT>x</TT>, of the form <TT>XxY</TT>  means <TT>X * e ^ Y</TT>  
where <TT>e</TT> is the familiar value 2.718281828.... 
<p>
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>e =: 1x1</TT></TD> 
<TD><TT>2x_1</TT></TD> 
<TD><TT>2 * e ^ _1</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>2.71828</TT></TD> 
<TD><TT>0.735759</TT></TD> 
<TD><TT>0.735759</TT></TD> 
</TABLE> 
<p>
These <TT>p</TT> and <TT>x</TT> forms of numeral provide a convenient way of writing constants 
accurately without writing out many digits. 
<p>
Finally, we can write numerals with a base other than 10.  
For example the binary or base-2 number with binary digits <TT>101</TT> has the value <TT>5</TT> 
 and can be written as <TT>2b101</TT>.  
<PRE>
   2b101 
5
</PRE>
<p>
The general scheme is that <TT>NbDDD.DDD</TT> is a numeral in number-base <TT>N</TT> with digits <TT>DDD.DDD</TT> . 
With bases larger than 10, we will need 
digits larger than 9, so we take letter <TT>'a'</TT> as a digit with value 10, <TT>'b'</TT> with value 11,  
and so on up to <TT>'z'</TT> with value 35.  
<p>
For example, letter <TT>'f'</TT> has digit-value 15, so in hexadecimal (base 16) the 
numeral written <TT>16bff</TT> has the value <TT>255</TT>.  
The number-base <TT>N</TT> is given in decimal. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>16bff</TT></TD> 
<TD><TT>(16 * 15) + 15</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>255</TT></TD> 
<TD><TT>255</TT></TD> 
</TABLE> 
<p>
One more example. <TT>10b0.9</TT> is evidently a base-10 number meaning "nine-tenths" and so,  
in base 20, <TT>20b0.f</TT> means "fifteen twentieths" 
<PRE>
   10b0.9 20b0.f
0.9 0.75
</PRE>
<H3>19.3.1  Combining the Notations</H3>
<p>
The notation-letters <TT>e</TT>, <TT>r</TT>, <TT>j</TT> <TT>ar</TT> <TT>ad</TT> <TT>p</TT> 
<TT>x</TT> and <TT>b</TT> may be used in combination.  
For example we can write <TT>1r2p1</TT> 
to mean "pi over two". Here are some further examples  
 of possible combinations. 
<p>
A numeral in the form <TT>XrY</TT> denotes the number 
<TT>X%Y</TT>.  A numeral in the form <TT>XeYrZ</TT> denotes  
the number <TT>(XeY) % Z</TT> because <TT>e</TT> is considered before <TT>r</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>1.2e2</TT></TD> 
<TD><TT>(1.2e2) % 4</TT></TD> 
<TD><TT>1.2e2r4</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>120</TT></TD> 
<TD><TT>30</TT></TD> 
<TD><TT>30</TT></TD> 
</TABLE> 
<p>
A numeral in the form <TT>XjY</TT> denotes the complex number 
<TT>(X j. Y)</TT> (that is, <TT>(X + (%: _1) * Y)</TT>. 
A numeral in the form <TT>XrYjZ</TT> denotes the number 
<TT>(XrY) j. Z</TT> because <TT>r</TT> is considered before <TT>j</TT> 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>3r4</TT></TD> 
<TD><TT>(3r4) j. 5</TT></TD> 
<TD><TT>3r4j5</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>3r4</TT></TD> 
<TD><TT>0.75j5</TT></TD> 
<TD><TT>0.75j5</TT></TD> 
</TABLE> 
<p>
A numeral in the form <TT>XpY</TT> denotes the number 
<TT>X*pi^Y</TT>. A numeral in the form <TT>XjYpZ</TT> denotes 
<TT>(XjY) *pi^Z</TT> because <TT>j</TT> is considered before <TT>p</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>3j4p5</TT></TD> 
<TD><TT>(3j4) * pi ^ 5</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>918.059j1224.08</TT></TD> 
<TD><TT>918.059j1224.08</TT></TD> 
</TABLE> 
<p>
A numeral in the form <TT>XbY</TT> denotes the number 
<TT>Y-in-base-X</TT>.  A numeral in the form <TT>XpYbZ</TT> 
denotes the number <TT>Z-in-base-(XpY)</TT> because 
<TT>p</TT> is considered before <TT>b</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>(3*pi)+5</TT></TD> 
<TD><TT>1p1b35</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>14.4248</TT></TD> 
<TD><TT>14.4248</TT></TD> 
</TABLE> 
<A NAME="13"></A><H2>19.4  How Numbers are Displayed</H2>
<p>
A number is displayed by J with, by default, up to 6 or 7 
significant digits. 
This means that, commonly, small integers are shown exactly, 
while large numbers, or numbers with many  
significant digits, are shown approximately. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>10 ^ 3</TT></TD> 
<TD><TT>2.7182818285</TT></TD> 
<TD><TT>2.718281828 * 10 ^ 7</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>1000</TT></TD> 
<TD><TT>2.71828</TT></TD> 
<TD><TT>2.71828e7</TT></TD> 
</TABLE> 
<p>
The number of significant digits used 
for display is determined by a global variable 
called the "print-precision".  If we define 
the two functions: 
<PRE>
   ppq =: 9 !: 10    NB. print-precision query
   pps =: 9 !: 11    NB. print-precision set
</PRE>
<p>
then the expression <TT>ppq ''</TT> gives the value 
of print-precision currently in effect, while 
<TT>pps n</TT> will set the print-precision to <TT>n</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>ppq ''</TT></TD> 
<TD><TT>e =: 2.718281828</TT></TD> 
<TD><TT>pps 8</TT></TD> 
<TD><TT>e</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>6</TT></TD> 
<TD><TT>2.71828</TT></TD> 
<TD><TT>&nbsp;</TT></TD> 
<TD><TT>2.7182818</TT></TD> 
</TABLE> 
<A NAME="14"></A><H3>19.4.1  The "Format" Verb</H3>
<p>
There is a built-in verb <TT>":</TT> 
 (doublequote colon, called "Format"). 
Monadic Format converts a number into a string  
 representing the number with the print-precision 
currently in effect. In the following example, 
note that <TT>a</TT> is a scalar,  
while the formatted representation of <TT>a</TT> is a list of characters. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>a =: 1 % 3</TT></TD> 
<TD><TT>": a</TT></TD> 
<TD><TT>$ ": a</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>0.33333333</TT></TD> 
<TD><TT>0.33333333</TT></TD> 
<TD><TT>10</TT></TD> 
</TABLE> 
<p>
The argument can be a list of numbers and the result is 
a single string. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>b =: 1 % 3 4 </TT></TD> 
<TD><TT>": b</TT></TD> 
<TD><TT>$ b</TT></TD> 
<TD><TT>$ ": b</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>0.33333333 0.25</TT></TD> 
<TD><TT>0.33333333 0.25</TT></TD> 
<TD><TT>2</TT></TD> 
<TD><TT>15</TT></TD> 
</TABLE> 
<p>
Dyadic Format allows more control over the 
representation.  
The left argument is complex: a value of  
say, <TT>8j4</TT> will format the numbers in a width of  
<TT>8</TT> characters and with <TT>4</TT> decimal places. 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>c =: % 1 + i. 2 2</TT></TD> 
<TD><TT>w =: 8j4 ": c</TT></TD> 
<TD><TT>$ w</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;0.5<BR> 
0.33333333 0.25</TT></TD> 
<TD><TT>&nbsp;&nbsp;1.0000&nbsp;&nbsp;0.5000<BR> 
&nbsp;&nbsp;0.3333&nbsp;&nbsp;0.2500</TT></TD> 
<TD><TT>2 16</TT></TD> 
</TABLE> 
<p>
If the width is specified as zero (as in say <TT>0j3</TT>) 
then sufficient width is allowed. If the number of decimal places 
is negative (as in <TT>10j_3</TT>) then numbers are shown in "scientific notation" 
<p>
<TABLE CELLPADDING=10 BORDER=1> 
<TR  VALIGN=TOP> 
<TD><TT>c </TT></TD> 
<TD><TT>0j3 ": c</TT></TD> 
<TD><TT>10j_3 ": c</TT></TD> 
<TR VALIGN=TOP> 
<TD><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;0.5<BR> 
0.33333333 0.25</TT></TD> 
<TD><TT>1.000 0.500<BR> 
0.333 0.250</TT></TD> 
<TD><TT> 1.000e0&nbsp;&nbsp;&nbsp;5.000e_1<BR> 
 3.333e_1&nbsp;&nbsp;2.500e_1</TT></TD> 
</TABLE> 
<A NAME="15"></A><A NAME="16"></A><H2>19.5  Random Numbers</H2>
<H3>19.5.1  Roll</H3>
<p>
There are built-in functions for generating random 
numbers.  Monadic <TT>?</TT> is called "Roll", because 
<TT>? n</TT> gives the result of rolling a die with <TT>n</TT> faces 
marked <TT>0</TT> to <TT>n-1</TT>. 
<PRE>
   ? 6
4
</PRE>
<p>
That is, <TT>? n</TT> is selected from the items of <TT>i. n</TT> 
randomly with equal probability. 
<p>
A list of random numbers is generated 
by repeating the n-value. 
For example, four rolls of a six-sided die is given by  
<PRE>
   ? 6 6 6 6
3 4 5 2
</PRE>
<p>
or more conveniently by: 
<PRE>
   ? 4 $ 6
2 3 5 3
</PRE>
<H3>19.5.2  Uniform Distribution</H3>
<p>
With an argument of zero, monadic <TT>?</TT> generates random reals 
uniformly distributed,  greater than <TT>0</TT> and less than <TT>1</TT>.  
<PRE>
   ? 0 0 0 0
0.14112615 0.083891464 0.41388488 0.055053198
   
</PRE>
<H3>19.5.3  Normal Distribution</H3>
<p>
The built-in verb <TT>?</TT> generates equiprobable numbers. 
Various other distributions 
are provided by library script <TT>statdist.ijs</TT>. 
<PRE>
   require 'statdist'
</PRE>
<p>
Reals normally distributed with mean 0 and standard deviation 1 are generated with  
<TT>normalrand</TT> 
<PRE>
   normalrand 6
0.84096966 0.59389446 1.5530828 0.69271405 0.87141049 _0.53649589
</PRE>
<p>
Other distributions are available in the <TT>statdist</TT> script. 
<A NAME="17"></A><H3>19.5.4  Deal</H3>
<p>
Dyadic <TT>?</TT> is called "Deal".  <TT>x ? y</TT> is a list of <TT>x</TT> integers randomly chosen  
from <TT>i. y</TT> without replacement, that is, the <TT>x</TT> integers are all different. 
<p>
Suppose that cards in a deck are numbered <TT>0</TT> to <TT>51</TT>, 
then <TT>13 ? 52</TT> will deal a single hand of 13 randomly selected cards, all different.  
<PRE>
   13 ? 52
28 46 4 24 19 27 5 12 10 13 49 21 42
</PRE>
<p>
A shuffle of the whole deck is given by <TT>52 ? 52</TT>.  
To shuffle and then deal four hands:  
<PRE>
   4 13 $ 52 ? 52
25 12  1 14 37 29 43 33 27  5 11 26 47
49 23 50  9 39  4 51 18 38 22 19  8  0
24 36 32 10 13 16  6 48 20 42 28 30  3
15 31 21 40  2 45 17 41 35 46  7 44 34
   
</PRE>
<p>
This brings us to the end of Chapter 19. 
  </tr> </table>

<HR> 
<p ALIGN=CENTER>
<A HREF="20.htm"> NEXT </A> <BR>
<A HREF="contents.htm#toc"> Table of Contents </A> <BR>
<A HREF="kwic.htm"> Index </A>

<HR>

<P ALIGN=CENTER>

<FONT SIZE=-1>The examples in this chapter 
were executed using J version 601-o-beta. 
This chapter last updated 25 Jun 2006 . 
<BR>
Copyright &copy; Roger Stokes 2006. 
This material may be freely reproduced,
provided that this copyright notice is also reproduced.
</FONT>



<!--bottom jump start--><hr><a href="20.htm">&gt;&gt;</a>&nbsp;
<a href="18.htm">&lt;&lt;</a>&nbsp;
<a href="../user/contents.htm">Usr</a>&nbsp;
<a href="../primer/contents.htm">Pri</a>&nbsp;
<a href="../jforc/contents.htm">JfC</a>&nbsp;
<a href="../learning/contents.htm">LJ</a>&nbsp;
<a href="../phrases/contents.htm">Phr</a>&nbsp;
<a href="../dictionary/contents.htm">Dic</a>&nbsp;
<a href="../release/contents.htm">Rel</a>&nbsp;
<a href="../dictionary/vocabul.htm">Voc</a>&nbsp;
<a href="../dictionary/xmain.htm">!:</a>&nbsp;
<a href="../index.htm">Help</a>&nbsp;
Learning J<!--bottom jump end--></BODY>
</HTML>
